# PreCon - 네이버 프리미엄 콘텐츠

## 서비스 소개

### 네이버 프리미엄 콘텐츠 서비스 클로닝 및 개선

- 텍스트 기반 정보 콘텐츠 제공 플랫폼

## 기획 동기

1. “Premium Contents.” 이름에서 고급화 전략이 기반인 서비스로 보여 흥미를 가지게 되었습니다. 그러나 대형 플랫폼에서 Infra가 제공된 것에 비해 차별화 및 대중화가 아쉬웠으며, UI도 개선이 필요한 서비스라고 생각했습니다. 단점 분석 및 개선, 서비스 고도화를 하며 다양한 도전을 위해 선정했습니다.
2. 제공하고 있는 API나 기술들이 대부분의 플랫폼 서비스의 기반이 되는 기능들이기 때문에 기능 구현과 친숙해지기 좋은 프로젝트라고 생각하여 선정했습니다.

# 오리지널 서비스 분석 및 프로젝트 방향성 수립

### **장점**

- Youtube, TikTok과 같은 시장 점유율이 압도적인 동영상 컨텐츠 기반 제공 플랫폼이 존재하므로 텍스트 기반 컨텐츠라는 시장을 잘 노린 것으로 보입니다.
- 검증된 컨텐츠 제공으로 정보의 정합성을 확보할 수 있어, 사용자가 노이즈 정보를 만날 확률이 적습니다.
- 네이버가 제공하는 Infra를 사용할 수 있으므로 대중화된 타 서비스와의 연결과 노출이 상대적으로 쉽습니다. (실제 서비스의 Merit)

### **단점 및 개선 방안**

- **각 기능에 대한 가이드라인이 미흡하고 UI의 배치가 사용자 중심적이지 않습니다.**
    - 첫 사용자가 기본적인 서비스를 이용할 수 있도록 가이드 기능을 추가합니다.
    - 각 서비스의 명명이나 가이드를 기능에 따라 명확하게 합니다.
    - 예상 사용 빈도에 따라 UI를 재배치합니다.
- **고급화 전략을 사용하는 만큼 더욱 세세한 맨투맨 컨텐츠가 필요합니다.**
    - 유료 서비스라 접근성이 떨어져 사용자의 초기 DATA를 확보하기 어렵습니다. 
    → 서비스 첫 접속시 간단한 사전 조사를 통해 채널 추천 알고리즘을 적용합니다.
- **접근성이 떨어져 존재 여부조차 모를 정도입니다.**
    - 네이버의 대중적인 서비스와 연동합니다. (예: 네이버 시리즈, 웹툰 리뷰 채널)

## **프로젝트 방향성**

<aside>
💡 **기존 서비스의 정체성을 유지하되, 소비자의 편의성을 최우선으로 고려하여 세부 기능을  개선합니다.**

</aside>

---

# 프로젝트 일정

### 03.20 ~ 03.31

-프로젝트 기획 및 ERD, 기능 명세서, REST API 구성

### 03.31 ~ 04.09

-Ver.1 기능 구현

[![Untitled](https://file.notion.so/f/s/c1a3ea9c-c60d-48fd-9ae7-d5c93606f208/Untitled.png?id=3153469d-1d60-4c9f-bce9-464213e400cd&table=block&spaceId=565d5f0b-c60d-4ff6-93ca-460362338240&expirationTimestamp=1689343200000&signature=BVX1tr_o2mHZzYcgwiDVELMSEV5bXolP0trE0nY_DUY&downloadName=Untitled.png)

### 04.10 ~ 04.30

-ver.1 FeedBack 및 개선 사항 추가

-ver.2 기능 구현

### 05.01 ~ 05.14

-ver.2 FeedBack 및 개선 사항 추가

-ver.3 기능 구현

-Original 사이트와 비교 분석 및 평가

### 05.15 ~ 06.11(max)

-App 개발

## 고민한 내용 (~4. 09)

- 일간, 주간, 월간 Rank 서비스는 주기적으로 Data 갱신이 이루어져야 하고, 갱신이 필요할 때 마다 View 파트에서 API를 요청하는 것이 비효율적이라고 생각하여 BE Server에 내부 Timer를 구현하여 주기마다 갱신하고, 효율적으로 정보를 갱신하게 하였습니다.
- 검색, 추천 기능과 같이 인덱스가 설계되어 있지 않은 DB에 저장되어 있는 값을  찾을 때, DB에서 직접 query 실행과 JPA QueryDSL 사용 중 어떤 것이 더 효율적일지 고민하였습니다.
- 구독관리 관련 DB 설계 및 최적화
    - 유저와 채널 간 구독 관리
        
        USER 테이블과 CHANNEL 테이블 간 바인딩은 따로 하지 않고
        
        각 테이블에 USER, CHANNEL LIST(서로의 INDEX를 저장)를 만들어서 관리하기로 함.
        
        중계 테이블은 여러 종류의 CLASS들을 관리하는 것이 아니기에 불필요하다고 판단했으나
        
        mapping 없이 List형태를 저장에 실패.
        
        - jpa List 형식 초기화 안됨
            
            뉴스레터,플레이리스트를 contentsCategory 테이블에 넣기
            
        
        그래서 one to many를 양방향으로 선언하여 many to many와 유사하게 구현하려 했으나
        
        비효율적이고 안정적이지 않아 (why) 비추천되어
        
        결국 중계테이블을 사용하는 방식을 사용.
        
    - 구독 관리 방법의 성능에 대한 고찰
        
        List로 db를 관리했을 때 DB 내에서 table이 어떻게 생성되는가? (독립적으로 list table이 만들어지나?)
        
        List로 관리할 시 추후 data 양이 많아지면 조회,추가,삭제 등에서 query의 실행 지연은 어떻게 해결할 것인가.
        
        테이블 간 연결 oneToMany와 List<String> 방식으로 연결성을 떨어뜨리는 방식의 선택
        
    - 유료 구독에 관한 관리에 대한 고찰
        
        중계 테이블에 시각을 넣어 놓는다. 
        
- 댓글, 대댓글
    
    오리지널 사이트에서는 대댓글이 2개 이상 연관 되지 않는데
    
    2개 이상으로 할 경우 구현에서 childComment가 comment를 상속 받을지 고민하다
    
    원래 사이트에 중복 대댓글이 없어서 상속받았을때 다중 대댓글 구현하기 쉽다고 생각하여 
    
    상속 받는 방향으로..
    
    상속 받을 때 private한 property들은 재사용이 불가능해서 domain에 재작성해야 했지만
    
    property 명을 같게 하고 상속 받으면 Comment에서 구현한 infra,method들을 사용할 수 있다고 생각했으나 따로 domain을 만드는 것에 큰 메리트가 없다고 생각하여 
    
    comment 내 parent,child property로 맵핑하여 관리
    
- 정합성 보단, insert 성능이 필요하다
    
    “좋아요처럼 데이터의 정합성이 크게 요구되지 않는다면, 정합성을 약간 포기하고 배치 시스템을 적용해서 insert 부하를 줄였다.” 와 같이 Redis를 적용한 판단 기준, 왜 Redis로 문제를 해결했는지, Redis를 사용해서 아쉬웠던 점이 있다면 어떻게 개선하는 게 좋을지 등등 기술에 대한 디테일이 들어가는 것이 중요할 것 같습니다.
    

## 기술적 도전 (~4. 19)

- 사용자에게 실시간으로 가시적인 data를 보여줘야 하는 서비스(Chat)에서는 FirebaseStore, 저장 및 삭제가 잦은 서비스(Rank)에서는 Redis, 일반적인 board 서비스에서는 mysql을 사용하여 RDBMS,NoSQL을 혼용하며 성능 개선을 하였습니다.
    - 랭킹, tag관리
        
        nosql (redis)로 랭킹 관리
        
        redis 장점 → 정리할 것.
        
- 실제 배포 중인 서비스에는 app이 없어 제작 예정.

## 새롭게 배우게 된 것 (~4. 19)

- 바인딩된 테이블을 orphanRemoval로 손쉽게 삭제할 수 있다.
- 

## 기타 (적용한 것) (~4. 19)

- **(예정) Interceptor 적용**

   - 구독자, 비구독자, 채널 보유자에 따라 렌더링해야 될 화면이 크게 다름 

      ⇒ 인증에 Interceptor를 구현하여 사용자 인증 용이, 코드 가독성 개선

- **(예정) 목적에 따른 DTO 세분화**

   - 채널, 콘텐츠 등의 일부 property에 대한 조회가 필요할 때

 ⇒ DTO 세분화로 가독성 증진 및 서버 부하를 줄임.

- **(예정) Service(인터페이스), ServiceImpl(구현체) 분리**

   - 구현체의 클라이언트 코드에 대한 독립적 확장을 위함 (OCP) 

- **(예정) 이미지 업로드 API 분리**

   -  API 사용 빈도, 페이지당 요청,응답 횟수에 따라 분석하여 기능 분리

      ⇒ 서버 부하 감소, 사용성 UP  

## FeedBack (~4. 19)

**Ver.1 FeedBack**

- Step by Step 에 따라 ver.1에서 구현하고자 한 바를 잘 지키면서 한 것 같다.
- 세부 기능 개발 단계에 들어가기 전 필요한 요구사항을 모두 충족시킨 것 같다.

## 변경한 주요 페이지 (~04. 09)

[![캡처.PNG](https://file.notion.so/f/s/298ff0e8-7846-4e5a-98e1-4ccecd320a2b/%EC%BA%A1%EC%B2%98.png?id=5c3db84e-8056-4d32-b4ac-786c0fab4719&table=block&spaceId=565d5f0b-c60d-4ff6-93ca-460362338240&expirationTimestamp=1689343200000&signature=ami0OS6KUP8gCXUQfBr3UNZTISrH3wChRifOVqe9aJQ&downloadName=%EC%BA%A1%EC%B2%98.PNG.png)
→ 내부 점수 알고리즘을 적용하여 메인 페이지에 노출되는 인기 파트너 채널을 기간별 Rank 순으로 노출합니다. 원본 사이트보다 더 Wide하게 구성하여 채널별 가독성을 개선했습니다.

## GitHub Repository

- front-end
    
    https://github.com/Haru-arp/premiumContents
    
- back-end
    
    https://github.com/umjiyong/precon
